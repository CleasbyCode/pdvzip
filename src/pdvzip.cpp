// 	PNG Data Vehicle, ZIP Edition (PDVZIP v2.2). Created by Nicholas Cleasby (@CleasbyCode) 6/08/2022

//	To compile program (Linux):
// 	$ g++ pdvzip.cpp -O2 -s -o pdvzip

// 	Run it:
// 	$ ./pdvzip

#include <algorithm>
#include <fstream>
#include <iostream>
#include <regex>
#include <string>
#include <vector>

typedef unsigned char Byte;

struct PDV_STRUCT {
	const size_t MAX_FILE_SIZE = 209715200;
	std::vector<Byte> Image_Vec, Idat_Zip_Vec;
	const char LINUX_PROBLEM_CHARACTERS[7]{ 0x22, 0x27, 0x28, 0x29, 0x3B, 0x3E, 0x60 };
	std::string image_name, zip_name;
	size_t image_size{}, zip_size{}, combined_file_size{};
	unsigned short int value_length_bits = 32;
	bool isBigEndian = true, isZipFile = true;
};

size_t
	// Code to compute CRC32 for PNG chunks, is taken from: https://www.w3.org/TR/2003/REC-PNG-20031110/#D-CRCAppendix 
	Crc_Update(const size_t&, Byte*, const size_t&),
	Crc(Byte*, const size_t&);

void
	Open_Files(PDV_STRUCT&),
	Check_Image_File(PDV_STRUCT&, std::ifstream&, std::ifstream&),
	Check_Zip_File(PDV_STRUCT&, std::ifstream&),

	// Only keep critical chunks from users PNG cover image.
	Erase_Image_Chunks(PDV_STRUCT&, std::ifstream&), 

	Complete_Extraction_Script(PDV_STRUCT&),

	// Change embedded ZIP record offsets within the PNG image to their new index locations, so that it remains a valid, working ZIP archive. 
	Fix_Zip_Offset(PDV_STRUCT&, const size_t&),

	// Update values, such as chunk lengths, CRC, file sizes and other values. Writes them into the relevant vector index locations.
	Value_Updater(PDV_STRUCT&, std::vector<Byte>&, size_t&, const size_t&),

	Write_Polyglot_File(PDV_STRUCT&),
	Display_Info();

int main(int argc, char** argv) {

	PDV_STRUCT pdv;

	if (argc == 2 && std::string(argv[1]) == "--info") {
		Display_Info();
	}
	else if (argc < 3 || argc > 3) {
		std::cout << "\nUsage: pdvzip <png> <zip/jar>\n\t\bpdvzip --info\n\n";
	}
	else {
		pdv.image_name = argv[1];
		pdv.zip_name = argv[2];

		const std::regex REG_EXP("(\\.[a-zA-Z_0-9\\.\\\\\\s\\-\\/]+)?[a-zA-Z_0-9\\.\\\\\\s\\-\\/]+?(\\.[a-zA-Z0-9]+)?");
		const std::string
			GET_PNG_EXT = pdv.image_name.length() > 2 ? pdv.image_name.substr(pdv.image_name.length() - 3) : pdv.image_name,
			GET_ZIP_EXT = pdv.zip_name.length() > 2 ? pdv.zip_name.substr(pdv.zip_name.length() - 3) : pdv.zip_name;

		if (GET_PNG_EXT != "png" || GET_ZIP_EXT != "zip" && GET_ZIP_EXT != "jar" || !regex_match(pdv.image_name, REG_EXP) || !regex_match(pdv.zip_name, REG_EXP)) {
			std::cerr << (GET_PNG_EXT != "png" || GET_ZIP_EXT != "zip" ? "\nFile Type Error: Invalid file extension found. Expecting only '.png' followed by '.zip/.jar'"
				: "\nInvalid Input Error: Characters not supported by this program found within file name arguments") << ".\n\n";
			std::exit(EXIT_FAILURE);
		}

		if (GET_ZIP_EXT == "jar") {
			pdv.isZipFile = false;
		}

		Open_Files(pdv);
	}
	return 0;
}

void Open_Files(PDV_STRUCT& pdv) {

	std::ifstream
		image_ifs(pdv.image_name, std::ios::binary),
		zip_ifs(pdv.zip_name, std::ios::binary);

	if (!image_ifs || !zip_ifs) {
		std::cerr << "\nRead File Error: " << (!image_ifs ? "Unable to open image file" : "Unable to open ZIP file") << ".\n\n";
		std::exit(EXIT_FAILURE);
	}
	else {
		constexpr int
			MIN_IMAGE_SIZE = 68,
			MIN_ZIP_SIZE = 40;

		bool file_size_check = false;

		image_ifs.seekg(0, image_ifs.end);
		pdv.image_size = image_ifs.tellg();
		image_ifs.seekg(0, image_ifs.beg);

		zip_ifs.seekg(0, zip_ifs.end);
		pdv.zip_size = zip_ifs.tellg();
		zip_ifs.seekg(0, zip_ifs.beg);

		pdv.combined_file_size = pdv.image_size + pdv.zip_size;

		file_size_check = pdv.image_size > MIN_IMAGE_SIZE && pdv.zip_size > MIN_ZIP_SIZE && pdv.MAX_FILE_SIZE >= pdv.combined_file_size;

		if (!file_size_check) {
			std::cerr << "\nFile Size Error: " << (MIN_IMAGE_SIZE > pdv.image_size ? "Invalid PNG image. File too small"
				: (MIN_ZIP_SIZE > pdv.zip_size ? "Invalid ZIP file. File too small"
					: "The combined file size of your PNG image and ZIP file exceeds maximum limit")) << ".\n\n";
			std::exit(EXIT_FAILURE);
		}
		Check_Image_File(pdv, image_ifs, zip_ifs);
	}
}

void Check_Image_File(PDV_STRUCT& pdv, std::ifstream& image_ifs, std::ifstream& zip_ifs) {

	// Vector "Image_Vec" stores the user's PNG cover image. 
	pdv.Image_Vec.assign(std::istreambuf_iterator<char>(image_ifs), std::istreambuf_iterator<char>());

	pdv.image_size = pdv.Image_Vec.size();

	const std::string
		PNG_SIG = "\x89\x50\x4E\x47",
		PNG_END_SIG = "\x49\x45\x4E\x44\xAE\x42\x60\x82",
		READ_PNG_SIG{ pdv.Image_Vec.begin(), pdv.Image_Vec.begin() + PNG_SIG.length() },
		READ_PNG_END_SIG{ pdv.Image_Vec.end() - PNG_END_SIG.length(), pdv.Image_Vec.end() };

	if (READ_PNG_SIG != PNG_SIG || READ_PNG_END_SIG != PNG_END_SIG) {
		std::cerr << "\nImage File Error: File does not appear to be a valid PNG image.\n\n";
		std::exit(EXIT_FAILURE);
	}

	// Check a range of bytes within the "IHDR" chunk to make sure we have no problem characters that will break the Linux extraction script.
	// A script breaking character can appear within the width & height fields or the 4 byte CRC field of the "IHDR" chunk.
	// Manually modifying the dimensions (1% increase or decrease) of the image will resolve the issue. Repeat if necessary, or use a different image.

	int ihdr_chunk_index = 18;

	// From index location, increment through 14 bytes of the IHDR chunk within vector "Image_Vec" and check each byte with the 7 characters from LINUX_PROBLEM_CHARACTERS array.
	while (ihdr_chunk_index++ != 32) { // We start checking from the 19th character position of the IHDR chunk within vector "Image_Vec".
		for (int i = 0; i < 7; i++) {
			if (pdv.Image_Vec[ihdr_chunk_index] == pdv.LINUX_PROBLEM_CHARACTERS[i]) { // Problem character found, display error message and exit program as this issue needs to be fix manually.
				std::cerr <<
					"\nImage File Error:\n\nThe IHDR chunk of this image contains a character that will break the Linux extraction script."
					"\nTry modifying image dimensions (1% increase or decrease) to resolve the issue.\nRepeat if necessary, or try another image.\n\n";
				std::exit(EXIT_FAILURE);
			}
		}
	}

	// Check for supported image dimensions and color types.

	const int
		COVER_IMAGE_WIDTH = pdv.Image_Vec[18] << 8 | pdv.Image_Vec[19],
		COVER_IMAGE_HEIGHT = pdv.Image_Vec[22] << 8 | pdv.Image_Vec[23],
		COVER_PNG_COLOR_TYPE = pdv.Image_Vec[25] == 6 ? 2 : pdv.Image_Vec[25];

	constexpr int
		MAX_TRUECOLOR_DIMS = 899,		// 899 x 899 Max. supported dimensions for PNG Truecolor (PNG-32/24, color types 2 & 6).
		MAX_INDEXED_COLOR_DIMS = 4096,		// 4096 x 4096 Max. supported dimensions for PNG Indexed-color (PNG-8, color type 3).
		MIN_DIMS = 68,				// 68 x 68 Min. supported dimensions for both PNG Indexed-color & Truecolor.
		PNG_INDEXED_COLOR = 3,			// PNG-8, Indexed-color, color type value.
		PNG_TRUECOLOR = 2;			// PNG-24, Truecolour, color type value. (We use this value for PNG-32 (Truecolour with alpha, 6), as we consider them the same for this program.

	const bool
		VALID_COLOR_TYPE = (COVER_PNG_COLOR_TYPE == PNG_INDEXED_COLOR) ? true		// Checking for valid color type of PNG image (PNG-32/24 Truecolor or PNG-8 Indexed-color only).
		: ((COVER_PNG_COLOR_TYPE == PNG_TRUECOLOR) ? true : false),

		VALID_IMAGE_DIMS = (COVER_PNG_COLOR_TYPE == PNG_TRUECOLOR			// Checking for valid dimension size for PNG Truecolor (PNG-32/24) images.
			&& MAX_TRUECOLOR_DIMS >= COVER_IMAGE_WIDTH
			&& MAX_TRUECOLOR_DIMS >= COVER_IMAGE_HEIGHT
			&& COVER_IMAGE_WIDTH >= MIN_DIMS
			&& COVER_IMAGE_HEIGHT >= MIN_DIMS) ? true
		: ((COVER_PNG_COLOR_TYPE == PNG_INDEXED_COLOR					// Checking for valid dimension size for PNG Indexed-color (PNG-8) images.
			&& MAX_INDEXED_COLOR_DIMS >= COVER_IMAGE_WIDTH
			&& MAX_INDEXED_COLOR_DIMS >= COVER_IMAGE_HEIGHT
			&& COVER_IMAGE_WIDTH >= MIN_DIMS
			&& COVER_IMAGE_HEIGHT >= MIN_DIMS) ? true : false);

	if (!VALID_COLOR_TYPE || !VALID_IMAGE_DIMS) {
		std::cerr << "\nImage File Error: " << (!VALID_COLOR_TYPE ? "Color type of PNG image is not supported.\n\nPNG-32/24 (Truecolor) or PNG-8 (Indexed-Color) only"
			: "Dimensions of PNG image are not within the supported range.\n\nPNG-32/24 Truecolor: [68 x 68]<->[899 x 899].\nPNG-8 Indexed-Color: [68 x 68]<->[4096 x 4096]") << ".\n\n";
		std::exit(EXIT_FAILURE);
	}

	Erase_Image_Chunks(pdv, zip_ifs);
}

void Erase_Image_Chunks(PDV_STRUCT& pdv, std::ifstream& zip_ifs) {

	// For users cover image, just keep the critical PNG chunks: IHDR, *PLTE, IDAT & IEND. 

	std::vector<Byte>Temp_Vec;

	const int PNG_HEADER_IHDR_CHUNK = 33;

	// Copy the first 33 bytes of Image_Vec (vector containing user's cover image) into vector Temp_Vec (PNG header + IHDR chunk).
	Temp_Vec.insert(Temp_Vec.begin(), pdv.Image_Vec.begin(), pdv.Image_Vec.begin() + PNG_HEADER_IHDR_CHUNK);

	const std::string IDAT_SIG = "IDAT";

	// Search for first IDAT chunk.
	size_t idat_chunk_index = std::search(pdv.Image_Vec.begin(), pdv.Image_Vec.end(), IDAT_SIG.begin(), IDAT_SIG.end()) - pdv.Image_Vec.begin() - 4;  // -4 is to position the index at the start of the IDAT chunk's length field.

	// Make sure this is a valid IDAT chunk. Check its CRC value.

	// Get first IDAT chunk length value.
	const size_t
		FIRST_IDAT_CHUNK_LENGTH = ((static_cast<size_t>(pdv.Image_Vec[idat_chunk_index]) << 24)
			| (static_cast<size_t>(pdv.Image_Vec[idat_chunk_index + 1]) << 16)
			| (static_cast<size_t>(pdv.Image_Vec[idat_chunk_index + 2]) << 8)
			| (static_cast<size_t>(pdv.Image_Vec[idat_chunk_index + 3]))),

		FIRST_IDAT_CHUNK_CRC_INDEX = idat_chunk_index + FIRST_IDAT_CHUNK_LENGTH + 8,

		FIRST_IDAT_CHUNK_CRC = ((static_cast<size_t>(pdv.Image_Vec[FIRST_IDAT_CHUNK_CRC_INDEX]) << 24)
			| (static_cast<size_t>(pdv.Image_Vec[FIRST_IDAT_CHUNK_CRC_INDEX + 1]) << 16)
			| (static_cast<size_t>(pdv.Image_Vec[FIRST_IDAT_CHUNK_CRC_INDEX + 2]) << 8)
			| (static_cast<size_t>(pdv.Image_Vec[FIRST_IDAT_CHUNK_CRC_INDEX + 3]))),

		CALC_FIRST_IDAT_CHUNK_CRC = Crc(&pdv.Image_Vec[idat_chunk_index + 4], FIRST_IDAT_CHUNK_LENGTH + 4);

	if (FIRST_IDAT_CHUNK_CRC != CALC_FIRST_IDAT_CHUNK_CRC) {
		std::cerr << "\nImage File Error: CRC value for first IDAT chunk is invalid.\n\n";
		std::exit(EXIT_FAILURE);
	}

	// *For PNG-8 Indexed-color (3) images, we need to keep the PLTE chunk.
	if (Temp_Vec[25] == 3) {

		const std::string PLTE_SIG = "PLTE";
		const size_t PLTE_CHUNK_INDEX = std::search(pdv.Image_Vec.begin(), pdv.Image_Vec.end(), PLTE_SIG.begin(), PLTE_SIG.end()) - pdv.Image_Vec.begin() - 4;

		if (idat_chunk_index > PLTE_CHUNK_INDEX) {
			const size_t PLTE_CHUNK_LENGTH = ((static_cast<size_t>(pdv.Image_Vec[PLTE_CHUNK_INDEX + 1]) << 16)
				| (static_cast<size_t>(pdv.Image_Vec[PLTE_CHUNK_INDEX + 2]) << 8)
				| (static_cast<size_t>(pdv.Image_Vec[PLTE_CHUNK_INDEX + 3])));

			Temp_Vec.insert(Temp_Vec.end(), pdv.Image_Vec.begin() + PLTE_CHUNK_INDEX, pdv.Image_Vec.begin() + PLTE_CHUNK_INDEX + (PLTE_CHUNK_LENGTH + 12));
		}
		else {
			std::cerr << "\nImage File Error: Required PLTE chunk not found for PNG-8 Indexed-color image.\n\n";
			std::exit(EXIT_FAILURE);
		}
	}

	// Find all the IDAT chunks and copy them into Temp_Vec.
	while (pdv.image_size != idat_chunk_index + 4) {
		const size_t IDAT_CHUNK_LENGTH = ((static_cast<size_t>(pdv.Image_Vec[idat_chunk_index]) << 24)
			| (static_cast<size_t>(pdv.Image_Vec[idat_chunk_index + 1]) << 16)
			| (static_cast<size_t>(pdv.Image_Vec[idat_chunk_index + 2]) << 8)
			| (static_cast<size_t>(pdv.Image_Vec[idat_chunk_index + 3])));

		Temp_Vec.insert(Temp_Vec.end(), pdv.Image_Vec.begin() + idat_chunk_index, pdv.Image_Vec.begin() + idat_chunk_index + (IDAT_CHUNK_LENGTH + 12));
		idat_chunk_index = std::search(pdv.Image_Vec.begin() + idat_chunk_index + 6, pdv.Image_Vec.end(), IDAT_SIG.begin(), IDAT_SIG.end()) - pdv.Image_Vec.begin() - 4;
	}

	// Copy the last 12 bytes of Image_Vec (PNG footer content) into Temp_Vec.
	const int PNG_FOOTER_LENGTH = 12;

	Temp_Vec.insert(Temp_Vec.end(), pdv.Image_Vec.end() - PNG_FOOTER_LENGTH, pdv.Image_Vec.end());

	Temp_Vec.swap(pdv.Image_Vec);

	pdv.image_size = pdv.Image_Vec.size();

	Check_Zip_File(pdv, zip_ifs);
}

void Check_Zip_File(PDV_STRUCT& pdv, std::ifstream& zip_ifs) {

	// Vector "Idat_Zip_Vec" will store the user's ZIP (or JAR) file. The contents of the vector will later be inserted into the "Image_Vec" vector as the last IDAT chunk. 
	// We will need to update the CRC value (last 4-bytes) and the chunk length field (first 4-bytes) within this vector. Both fields are currently set to zero. 

	pdv.Idat_Zip_Vec = { 0x00, 0x00, 0x00, 0x00, 0x49, 0x44, 0x41, 0x54, 0x00, 0x00, 0x00, 0x00 };	// "IDAT" chunk name with 4-byte chunk length and CRC fields.

	// Insert user's ZIP file into vector "Idat_Zip_Vec" from index 8, just after the "IDAT" chunk name.
	pdv.Idat_Zip_Vec.insert(pdv.Idat_Zip_Vec.begin() + 8, std::istreambuf_iterator<char>(zip_ifs), std::istreambuf_iterator<char>());

	pdv.zip_size = pdv.Idat_Zip_Vec.size();

	size_t idat_chunk_length_index = 0;
	
	// Write the updated IDAT data chunk length value of vector "Idat_Zip_Vec" within its length field.
	// The data length value does not include the chunk length field, chunk name or chunk CRC field, which totals 12 bytes. 
	Value_Updater(pdv, pdv.Idat_Zip_Vec, idat_chunk_length_index, pdv.zip_size - 12);
	
	const std::string
		ZIP_SIG = "\x50\x4B\x03\x04",
		GET_ZIP_SIG{ pdv.Idat_Zip_Vec.begin() + 8, pdv.Idat_Zip_Vec.begin() + 8 + ZIP_SIG.length() };

	constexpr int MIN_INZIP_NAME_LENGTH = 4;			// Set minimum filename length for the compressed file. (1st filename record, listed within the ZIP archive).

	const int INZIP_NAME_LENGTH = pdv.Idat_Zip_Vec[34];		// Get the filename length of the compressed file (1st filename in ZIP record) from vector "Idat_Zip_Vec".

	if (GET_ZIP_SIG != ZIP_SIG || MIN_INZIP_NAME_LENGTH > INZIP_NAME_LENGTH) {
		std::cerr << "\nZIP File Error: " << (GET_ZIP_SIG != ZIP_SIG ? "File does not appear to be a valid ZIP archive"
			: "\n\nName length of first file within ZIP archive is too short.\nIncrease its length (minimum 4 characters) and make sure it has a valid extension") << ".\n\n";
		std::exit(EXIT_FAILURE);
	}
	Complete_Extraction_Script(pdv);
}

void Complete_Extraction_Script(PDV_STRUCT& pdv) {
	
	// "Extension_Vec" string vector stores file extensions for some common media types.
	std::vector<std::string> Extension_Vec{ "3gp", "aac", "aif", "ala", "chd", "avi", "dsd", "f4v", "lac", "flv", "m4a", "mkv", "mov", "mp3", "mp4", "mpg", "peg", "ogg", "pcm", "swf", "wav", "ebm", "wma", "wmv", "pdf", ".py", "ps1", "exe", ".sh" };

	constexpr int
		FIRST_ZIP_NAME_REC_LENGTH_INDEX = 34,	// Index location within "Idat_Zip_Vec" vector, for the length value of the compressed filename (1st filename listed within the ZIP file record).
		FIRST_ZIP_NAME_REC_INDEX = 38,		// Index start location within "Idat_Zip_Vec" for the name of the compressed file.
		VIDEO_AUDIO = 23,			// Linux uses "vlc" or "mpv" media player.  Windows will use the set default media player. 
		PDF = 24,				// Linux uses "evince" or "firefox" program for PDF files. Windows will use the set default PDF viewer.
		PYTHON = 25,				// Linux & Windows will use "python3" command to run Python scripts.
		POWERSHELL = 26,			// Linux Will use "pwsh" command (if installed) for PowerShell scripts. Windows will use the command pwsh.exe or powershell.exe, depending on the version of PowerShell installed. 
		WINDOWS_EXECUTABLE = 27,		// Just uses Windows default method to open the executable (.exe) file.
		BASH_SHELL = 28,			// After extraction, the extraction script first uses chmod +x to give the bash script (.sh) executable permissions, followed by ./your_script_file.sh to run it. Windows uses set default program for this file type.
		Default = 29,				// Unknown extension. Uses set default program to open unknown file types. Linux will use xdg-open command.
		FOLDER = 30,				// To open a zipped folder after extraction, for Windows, we use the command: powershell "II 'first_folder_name/second_folder_name/'". For Linux, we use xdg-open.
		LINUX_EXECUTABLE = 31,			// After extraction, the script uses chmod +x to give the file executable permissions, followed by ./your_executable_file to run it.
		JAR = 32;

	const int FIRST_ZIP_NAME_REC_LENGTH = pdv.Idat_Zip_Vec[FIRST_ZIP_NAME_REC_LENGTH_INDEX];	// Get the filename length value of the compressed file, from vector "Idat_Zip_Vec".
		
	std::string

		// Get the filename string of compressed file from vector "Idat_Zip_Vec". (1st file listed within the ZIP record).
		first_zip_name{ pdv.Idat_Zip_Vec.begin() + FIRST_ZIP_NAME_REC_INDEX, pdv.Idat_Zip_Vec.begin() + FIRST_ZIP_NAME_REC_INDEX + FIRST_ZIP_NAME_REC_LENGTH },

		// Get the file extension from the filename string (last three characters).
		first_zip_name_ext = first_zip_name.substr(first_zip_name.length() - 3, 3),

		// String variables for optional command-line arguments.
		args_linux{},
		args_windows{};

	unsigned short int extension_index = 0;

	if (pdv.isZipFile) {
		for (; extension_index != Default; extension_index++) {
			if (Extension_Vec[extension_index] == first_zip_name_ext) {
				// After a file extension match, any extension_index value between 0 and 23 defaults to VIDEO_AUDIO (23).
				extension_index = extension_index <= VIDEO_AUDIO ? VIDEO_AUDIO : extension_index;
				break;
			}
		}
	}
	else {
		extension_index = JAR;
	}

	if (extension_index == Default) { // no extension match 

		// If no file extensions from string vector "Extension_Vec" matched the compressed file's file extension, check to see if the file actually has an extension.

		// Check for "." character to see if the "first_zip_name" string has a file extension.
		const auto CHECK_FILE_EXT = first_zip_name.find_last_of('.');

		// If no file extension detected, check if "first_zip_name" points to a folder (/), else assume file without an extension is a Linux executable.
		if (CHECK_FILE_EXT == 0 || CHECK_FILE_EXT > first_zip_name.length()) {
			extension_index = pdv.Idat_Zip_Vec[FIRST_ZIP_NAME_REC_INDEX + FIRST_ZIP_NAME_REC_LENGTH - 1] == '/' ? FOLDER : LINUX_EXECUTABLE;
		}
	}

	// Provide the user with the option to add command-line arguments for these file types: 
	// Python (.py), PowerShell (.ps1), Shell script (.sh) and Executable (.exe) Windows/Linux. No file extension, defaults to LINUX_EXECUTABLE, if it's not a folder).
	// The provided arguments for the file type will be stored within the PNG image, as part of the relevant extraction script.

	if (extension_index > PDF && extension_index <= BASH_SHELL || extension_index == LINUX_EXECUTABLE) {

		std::cout << "\nFor this file type, if required, you can provide command-line arguments here.\n";
		if (extension_index != WINDOWS_EXECUTABLE) {
			std::cout << "\nLinux: ";
			std::getline(std::cin, args_linux);
		}
		if (extension_index != LINUX_EXECUTABLE) {
			std::cout << "\nWindows: ";
			std::getline(std::cin, args_windows);
		}
	}

	// Vector "Iccp_Script_Vec" contains the iCCP chunk header (4 byte chunk length field, 4 byte chunk name), followed by a number of common bytes shared 
	// by all the extraction scripts. The last 4 bytes is the CRC chunk field for iCCP.
	// Once the extraction script has been completed, it will be inserted into this vector, at index location 22.

	std::vector<Byte> Iccp_Script_Vec = { 0x00, 0x00, 0x00, 0x00, 0x69, 0x43, 0x43, 0x50, 0x44, 0x56, 0x5A, 0x49, 0x50, 0x5F,
						0x5F, 0x00, 0x00, 0x0D, 0x52, 0x45, 0x4D, 0x3B, 0x0D, 0x0A, 0x00, 0x00, 0x00, 0x00 };

	/* Vector "Extraction_Scripts_Array_Vec"

	This vector stores an array of vectors containing 9 different shell/batch extraction scripts used for extracting and opening the embedded zipped file or folder.

	Scripts support both Linux & Windows. A completed script, when executed, will create the subdirectory ./pdvzip_extracted, move itself (PNG image file) into that directory,
	unzip the archive from itself (PNG image file) and then, depending on the file type, it will attempt to open/display/play/run the extracted file,
	by using an application command based on the matched file extension, or if no was match found, defaulting to the operating system making the application choice. */

	std::vector<std::vector<Byte>> Extraction_Scripts_Array_Vec {

		// Script Vector 0 for playing common Video/Audio files.
		{	0x49, 0x54, 0x45, 0x4D, 0x3D, 0x22, 0x22, 0x3B, 0x44, 0x49, 0x52, 0x3D, 0x22, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63,
			0x74, 0x65, 0x64, 0x22, 0x3B, 0x4E, 0x55, 0x4C, 0x3D, 0x22, 0x2F, 0x64, 0x65, 0x76, 0x2F, 0x6E, 0x75, 0x6C, 0x6C, 0x22, 0x3B, 0x63, 0x6C, 0x65, 0x61, 0x72,
			0x3B, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2D, 0x70, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x6D, 0x76, 0x20, 0x22, 0x24, 0x30, 0x22, 0x20, 0x22,
			0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x63, 0x64, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x75, 0x6E, 0x7A, 0x69, 0x70, 0x20, 0x2D, 0x71, 0x6F, 0x20,
			0x22, 0x24, 0x30, 0x22, 0x3B, 0x68, 0x61, 0x73, 0x68, 0x20, 0x2D, 0x72, 0x3B, 0x69, 0x66, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x20, 0x2D, 0x76,
			0x20, 0x76, 0x6C, 0x63, 0x20, 0x3E, 0x24, 0x4E, 0x55, 0x4C, 0x20, 0x32, 0x3E, 0x26, 0x31, 0x3B, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x63, 0x6C, 0x65, 0x61, 0x72,
			0x3B, 0x76, 0x6C, 0x63, 0x20, 0x2D, 0x2D, 0x70, 0x6C, 0x61, 0x79, 0x2D, 0x61, 0x6E, 0x64, 0x2D, 0x65, 0x78, 0x69, 0x74, 0x20, 0x2D, 0x2D, 0x6E, 0x6F, 0x2D,
			0x76, 0x69, 0x64, 0x65, 0x6F, 0x2D, 0x74, 0x69, 0x74, 0x6C, 0x65, 0x2D, 0x73, 0x68, 0x6F, 0x77, 0x20, 0x22, 0x24, 0x49, 0x54, 0x45, 0x4D, 0x22, 0x20, 0x26,
			0x3E, 0x20, 0x24, 0x4E, 0x55, 0x4C, 0x3B, 0x65, 0x6C, 0x69, 0x66, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x20, 0x2D, 0x76, 0x20, 0x6D, 0x70, 0x76,
			0x20, 0x3E, 0x24, 0x4E, 0x55, 0x4C, 0x20, 0x32, 0x3E, 0x26, 0x31, 0x3B, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x6D, 0x70, 0x76,
			0x20, 0x2D, 0x2D, 0x71, 0x75, 0x69, 0x65, 0x74, 0x20, 0x22, 0x24, 0x49, 0x54, 0x45, 0x4D, 0x22, 0x20, 0x26, 0x3E, 0x20, 0x24, 0x4E, 0x55, 0x4C, 0x3B, 0x65,
			0x6C, 0x73, 0x65, 0x20, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x66, 0x69, 0x3B, 0x65, 0x78, 0x69, 0x74, 0x3B, 0x0D, 0x0A, 0x23, 0x26, 0x63, 0x6C, 0x73, 0x26,
			0x73, 0x65, 0x74, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x45, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x44, 0x65, 0x6C, 0x61, 0x79, 0x65, 0x64, 0x45, 0x78, 0x70, 0x61,
			0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x26, 0x73, 0x65, 0x74, 0x20, 0x44, 0x49, 0x52, 0x3D, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61,
			0x63, 0x74, 0x65, 0x64, 0x26, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x22, 0x25,
			0x7E, 0x64, 0x70, 0x6E, 0x78, 0x30, 0x22, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x63, 0x64, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21,
			0x26, 0x63, 0x6C, 0x73, 0x26, 0x74, 0x61, 0x72, 0x20, 0x2D, 0x78, 0x66, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x26, 0x72, 0x65,
			0x6E, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x20, 0x2A, 0x2E, 0x70, 0x6E, 0x67, 0x26, 0x22, 0x22, 0x26, 0x65, 0x78, 0x69, 0x74 },

		// Script Vector 1 for opening and displaying PDF documents.
		{	0x49, 0x54, 0x45, 0x4D, 0x3D, 0x22, 0x22, 0x3B, 0x44, 0x49, 0x52, 0x3D, 0x22, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63,
			0x74, 0x65, 0x64, 0x22, 0x3B, 0x4E, 0x55, 0x4C, 0x3D, 0x22, 0x2F, 0x64, 0x65, 0x76, 0x2F, 0x6E, 0x75, 0x6C, 0x6C, 0x22, 0x3B, 0x63, 0x6C, 0x65, 0x61, 0x72,
			0x3B, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2D, 0x70, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x6D, 0x76, 0x20, 0x22, 0x24, 0x30, 0x22, 0x20, 0x22,
			0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x63, 0x64, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x75, 0x6E, 0x7A, 0x69, 0x70, 0x20, 0x2D, 0x71, 0x6F, 0x20,
			0x22, 0x24, 0x30, 0x22, 0x3B, 0x68, 0x61, 0x73, 0x68, 0x20, 0x2D, 0x72, 0x3B, 0x69, 0x66, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x20, 0x2D, 0x76,
			0x20, 0x65, 0x76, 0x69, 0x6E, 0x63, 0x65, 0x20, 0x3E, 0x24, 0x4E, 0x55, 0x4C, 0x20, 0x32, 0x3E, 0x26, 0x31, 0x3B, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x63, 0x6C,
			0x65, 0x61, 0x72, 0x3B, 0x65, 0x76, 0x69, 0x6E, 0x63, 0x65, 0x20, 0x22, 0x24, 0x49, 0x54, 0x45, 0x4D, 0x22, 0x20, 0x26, 0x3E, 0x20, 0x24, 0x4E, 0x55, 0x4C,
			0x3B, 0x65, 0x6C, 0x73, 0x65, 0x20, 0x66, 0x69, 0x72, 0x65, 0x66, 0x6F, 0x78, 0x20, 0x22, 0x24, 0x49, 0x54, 0x45, 0x4D, 0x22, 0x20, 0x26, 0x3E, 0x20, 0x24,
			0x4E, 0x55, 0x4C, 0x3B, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x66, 0x69, 0x3B, 0x65, 0x78, 0x69, 0x74, 0x3B, 0x0D, 0x0A, 0x23, 0x26, 0x63, 0x6C, 0x73, 0x26,
			0x73, 0x65, 0x74, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x45, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x44, 0x65, 0x6C, 0x61, 0x79, 0x65, 0x64, 0x45, 0x78, 0x70, 0x61,
			0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x26, 0x73, 0x65, 0x74, 0x20, 0x44, 0x49, 0x52, 0x3D, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61,
			0x63, 0x74, 0x65, 0x64, 0x26, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x22, 0x25,
			0x7E, 0x64, 0x70, 0x6E, 0x78, 0x30, 0x22, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x63, 0x64, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21,
			0x26, 0x63, 0x6C, 0x73, 0x26, 0x74, 0x61, 0x72, 0x20, 0x2D, 0x78, 0x66, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x26, 0x72, 0x65,
			0x6E, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x20, 0x2A, 0x2E, 0x70, 0x6E, 0x67, 0x26, 0x22, 0x22, 0x26, 0x65, 0x78, 0x69, 0x74 },

		// Script Vector 2 for running Python programs.
		{	0x49, 0x54, 0x45, 0x4D, 0x3D, 0x22, 0x22, 0x3B, 0x44, 0x49, 0x52, 0x3D, 0x22, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63,
			0x74, 0x65, 0x64, 0x22, 0x3B, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2D, 0x70, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22,
			0x3B, 0x6D, 0x76, 0x20, 0x22, 0x24, 0x30, 0x22, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x63, 0x64, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B,
			0x75, 0x6E, 0x7A, 0x69, 0x70, 0x20, 0x2D, 0x71, 0x6F, 0x20, 0x22, 0x24, 0x30, 0x22, 0x3B, 0x68, 0x61, 0x73, 0x68, 0x20, 0x2D, 0x72, 0x3B, 0x69, 0x66, 0x20,
			0x63, 0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x20, 0x2D, 0x76, 0x20, 0x70, 0x79, 0x74, 0x68, 0x6F, 0x6E, 0x33, 0x20, 0x3E, 0x2F, 0x64, 0x65, 0x76, 0x2F, 0x6E,
			0x75, 0x6C, 0x6C, 0x20, 0x32, 0x3E, 0x26, 0x31, 0x3B, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x70, 0x79, 0x74, 0x68, 0x6F, 0x6E,
			0x33, 0x20, 0x22, 0x24, 0x49, 0x54, 0x45, 0x4D, 0x22, 0x20, 0x3B, 0x65, 0x6C, 0x73, 0x65, 0x20, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x66, 0x69, 0x3B, 0x65,
			0x78, 0x69, 0x74, 0x3B, 0x0D, 0x0A, 0x23, 0x26, 0x63, 0x6C, 0x73, 0x26, 0x73, 0x65, 0x74, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x45, 0x6E, 0x61, 0x62, 0x6C,
			0x65, 0x44, 0x65, 0x6C, 0x61, 0x79, 0x65, 0x64, 0x45, 0x78, 0x70, 0x61, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x26, 0x73, 0x65, 0x74, 0x20, 0x49, 0x54, 0x45, 0x4D,
			0x3D, 0x26, 0x73, 0x65, 0x74, 0x20, 0x41, 0x52, 0x47, 0x53, 0x3D, 0x26, 0x73, 0x65, 0x74, 0x20, 0x41, 0x50, 0x50, 0x3D, 0x70, 0x79, 0x74, 0x68, 0x6F, 0x6E,
			0x33, 0x26, 0x73, 0x65, 0x74, 0x20, 0x44, 0x49, 0x52, 0x3D, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x65, 0x64,
			0x26, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x22, 0x25, 0x7E, 0x64, 0x70, 0x6E,
			0x78, 0x30, 0x22, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x63, 0x64, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x63, 0x6C, 0x73,
			0x26, 0x74, 0x61, 0x72, 0x20, 0x2D, 0x78, 0x66, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x26, 0x72, 0x65, 0x6E, 0x20, 0x22, 0x25,
			0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x20, 0x2A, 0x2E, 0x70, 0x6E, 0x67, 0x26, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x21, 0x41, 0x50, 0x50, 0x21,
			0x20, 0x3E, 0x6E, 0x75, 0x6C, 0x20, 0x32, 0x3E, 0x26, 0x31, 0x20, 0x26, 0x26, 0x20, 0x28, 0x21, 0x41, 0x50, 0x50, 0x21, 0x20, 0x22, 0x21, 0x49, 0x54, 0x45,
			0x4D, 0x21, 0x22, 0x20, 0x21, 0x41, 0x52, 0x47, 0x53, 0x21, 0x20, 0x29, 0x20, 0x7C, 0x7C, 0x20, 0x28, 0x63, 0x6C, 0x73, 0x26, 0x65, 0x78, 0x69, 0x74, 0x29,
			0x26, 0x65, 0x63, 0x68, 0x6F, 0x2E, 0x26, 0x65, 0x78, 0x69, 0x74 },

		// Script Vector 3 for running PowerShell scripts.
		{	0x44, 0x49, 0x52, 0x3D, 0x22, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x65, 0x64, 0x22, 0x3B, 0x49, 0x54, 0x45,
			0x4D, 0x3D, 0x22, 0x22, 0x3B, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2D, 0x70, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22,
			0x3B, 0x6D, 0x76, 0x20, 0x22, 0x24, 0x30, 0x22, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x63, 0x64, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B,
			0x75, 0x6E, 0x7A, 0x69, 0x70, 0x20, 0x2D, 0x71, 0x6F, 0x20, 0x22, 0x24, 0x30, 0x22, 0x3B, 0x68, 0x61, 0x73, 0x68, 0x20, 0x2D, 0x72, 0x3B, 0x69, 0x66, 0x20,
			0x63, 0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x20, 0x2D, 0x76, 0x20, 0x70, 0x77, 0x73, 0x68, 0x20, 0x3E, 0x2F, 0x64, 0x65, 0x76, 0x2F, 0x6E, 0x75, 0x6C, 0x6C,
			0x20, 0x32, 0x3E, 0x26, 0x31, 0x3B, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x70, 0x77, 0x73, 0x68, 0x20, 0x22, 0x24, 0x49, 0x54,
			0x45, 0x4D, 0x22, 0x20, 0x3B, 0x65, 0x6C, 0x73, 0x65, 0x20, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x66, 0x69, 0x3B, 0x65, 0x78, 0x69, 0x74, 0x3B, 0x0D, 0x0A,
			0x23, 0x26, 0x63, 0x6C, 0x73, 0x26, 0x73, 0x65, 0x74, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x45, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x44, 0x65, 0x6C, 0x61, 0x79,
			0x65, 0x64, 0x45, 0x78, 0x70, 0x61, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x26, 0x73, 0x65, 0x74, 0x20, 0x49, 0x54, 0x45, 0x4D, 0x3D, 0x26, 0x73, 0x65, 0x74, 0x20,
			0x41, 0x52, 0x47, 0x53, 0x3D, 0x26, 0x73, 0x65, 0x74, 0x20, 0x44, 0x49, 0x52, 0x3D, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61,
			0x63, 0x74, 0x65, 0x64, 0x26, 0x73, 0x65, 0x74, 0x20, 0x50, 0x44, 0x49, 0x52, 0x3D, 0x22, 0x25, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x44, 0x72, 0x69, 0x76,
			0x65, 0x25, 0x5C, 0x50, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x46, 0x69, 0x6C, 0x65, 0x73, 0x5C, 0x50, 0x6F, 0x77, 0x65, 0x72, 0x53, 0x68, 0x65, 0x6C,
			0x6C, 0x5C, 0x22, 0x26, 0x63, 0x6C, 0x73, 0x26, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x6D, 0x6F, 0x76, 0x65,
			0x20, 0x22, 0x25, 0x7E, 0x64, 0x70, 0x6E, 0x78, 0x30, 0x22, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x63, 0x64, 0x20, 0x2E, 0x5C, 0x21, 0x44,
			0x49, 0x52, 0x21, 0x26, 0x63, 0x6C, 0x73, 0x26, 0x74, 0x61, 0x72, 0x20, 0x2D, 0x78, 0x66, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22,
			0x26, 0x72, 0x65, 0x6E, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x20, 0x2A, 0x2E, 0x70, 0x6E, 0x67, 0x26, 0x49, 0x46, 0x20, 0x45,
			0x58, 0x49, 0x53, 0x54, 0x20, 0x21, 0x50, 0x44, 0x49, 0x52, 0x21, 0x20, 0x28, 0x70, 0x77, 0x73, 0x68, 0x20, 0x2D, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69,
			0x6F, 0x6E, 0x50, 0x6F, 0x6C, 0x69, 0x63, 0x79, 0x20, 0x42, 0x79, 0x70, 0x61, 0x73, 0x73, 0x20, 0x2D, 0x46, 0x69, 0x6C, 0x65, 0x20, 0x22, 0x21, 0x49, 0x54,
			0x45, 0x4D, 0x21, 0x22, 0x20, 0x21, 0x41, 0x52, 0x47, 0x53, 0x21, 0x26, 0x65, 0x63, 0x68, 0x6F, 0x2E, 0x26, 0x65, 0x78, 0x69, 0x74, 0x29, 0x20, 0x45, 0x4C,
			0x53, 0x45, 0x20, 0x28, 0x70, 0x6F, 0x77, 0x65, 0x72, 0x73, 0x68, 0x65, 0x6C, 0x6C, 0x20, 0x2D, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x50,
			0x6F, 0x6C, 0x69, 0x63, 0x79, 0x20, 0x42, 0x79, 0x70, 0x61, 0x73, 0x73, 0x20, 0x2D, 0x46, 0x69, 0x6C, 0x65, 0x20, 0x22, 0x21, 0x49, 0x54, 0x45, 0x4D, 0x21,
			0x22, 0x20, 0x21, 0x41, 0x52, 0x47, 0x53, 0x21, 0x26, 0x65, 0x63, 0x68, 0x6F, 0x2E, 0x26, 0x65, 0x78, 0x69, 0x74, 0x29 },

		// Script Vector 4 for running a Windows executable file.
		{	0x44, 0x49, 0x52, 0x3D, 0x22, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x65, 0x64, 0x22, 0x3B, 0x63, 0x6C, 0x65,
			0x61, 0x72, 0x3B, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2D, 0x70, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x6D, 0x76, 0x20, 0x22, 0x24, 0x30, 0x22,
			0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x63, 0x64, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x75, 0x6E, 0x7A, 0x69, 0x70, 0x20, 0x2D, 0x71,
			0x6F, 0x20, 0x22, 0x24, 0x30, 0x22, 0x3B, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x65, 0x78, 0x69, 0x74, 0x3B, 0x0D, 0x0A, 0x23, 0x26, 0x63, 0x6C, 0x73, 0x26,
			0x73, 0x65, 0x74, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x45, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x44, 0x65, 0x6C, 0x61, 0x79, 0x65, 0x64, 0x45, 0x78, 0x70, 0x61,
			0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x26, 0x73, 0x65, 0x74, 0x20, 0x44, 0x49, 0x52, 0x3D, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61,
			0x63, 0x74, 0x65, 0x64, 0x26, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x22, 0x25,
			0x7E, 0x64, 0x70, 0x6E, 0x78, 0x30, 0x22, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x63, 0x64, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21,
			0x26, 0x63, 0x6C, 0x73, 0x26, 0x74, 0x61, 0x72, 0x20, 0x2D, 0x78, 0x66, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x26, 0x72, 0x65,
			0x6E, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x20, 0x2A, 0x2E, 0x70, 0x6E, 0x67, 0x26, 0x22, 0x22, 0x20, 0x26, 0x65, 0x63, 0x68,
			0x6F, 0x2E, 0x26, 0x65, 0x78, 0x69, 0x74 },

		// Script Vector 5 for running Bash Shell scripts.
		{	0x49, 0x54, 0x45, 0x4D, 0x3D, 0x22, 0x22, 0x3B, 0x44, 0x49, 0x52, 0x3D, 0x22, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63,
			0x74, 0x65, 0x64, 0x22, 0x3B, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2D, 0x70, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22,
			0x3B, 0x6D, 0x76, 0x20, 0x22, 0x24, 0x30, 0x22, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x63, 0x64, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B,
			0x75, 0x6E, 0x7A, 0x69, 0x70, 0x20, 0x2D, 0x71, 0x6F, 0x20, 0x22, 0x24, 0x30, 0x22, 0x3B, 0x63, 0x68, 0x6D, 0x6F, 0x64, 0x20, 0x2B, 0x78, 0x20, 0x22, 0x24,
			0x49, 0x54, 0x45, 0x4D, 0x22, 0x3B, 0x2E, 0x2F, 0x22, 0x24, 0x49, 0x54, 0x45, 0x4D, 0x22, 0x20, 0x3B, 0x65, 0x78, 0x69, 0x74, 0x3B, 0x0D, 0x0A, 0x23, 0x26,
			0x63, 0x6C, 0x73, 0x26, 0x73, 0x65, 0x74, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x45, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x44, 0x65, 0x6C, 0x61, 0x79, 0x65, 0x64,
			0x45, 0x78, 0x70, 0x61, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x26, 0x73, 0x65, 0x74, 0x20, 0x44, 0x49, 0x52, 0x3D, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65,
			0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x65, 0x64, 0x26, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x6D, 0x6F, 0x76,
			0x65, 0x20, 0x22, 0x25, 0x7E, 0x64, 0x70, 0x6E, 0x78, 0x30, 0x22, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x63, 0x64, 0x20, 0x2E, 0x5C, 0x21,
			0x44, 0x49, 0x52, 0x21, 0x26, 0x63, 0x6C, 0x73, 0x26, 0x74, 0x61, 0x72, 0x20, 0x2D, 0x78, 0x66, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30,
			0x22, 0x26, 0x72, 0x65, 0x6E, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x20, 0x2A, 0x2E, 0x70, 0x6E, 0x67, 0x26, 0x22, 0x22, 0x20,
			0x26, 0x63, 0x6C, 0x73, 0x26, 0x65, 0x78, 0x69, 0x74 },

		// Script Vector 6 for opening Folders.
		{	0x49, 0x54, 0x45, 0x4D, 0x3D, 0x22, 0x22, 0x3B, 0x44, 0x49, 0x52, 0x3D, 0x22, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63,
			0x74, 0x65, 0x64, 0x22, 0x3B, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2D, 0x70, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22,
			0x3B, 0x6D, 0x76, 0x20, 0x22, 0x24, 0x30, 0x22, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x63, 0x64, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B,
			0x75, 0x6E, 0x7A, 0x69, 0x70, 0x20, 0x2D, 0x71, 0x6F, 0x20, 0x22, 0x24, 0x30, 0x22, 0x3B, 0x78, 0x64, 0x67, 0x2D, 0x6F, 0x70, 0x65, 0x6E, 0x20, 0x22, 0x24,
			0x49, 0x54, 0x45, 0x4D, 0x22, 0x20, 0x26, 0x3E, 0x20, 0x2F, 0x64, 0x65, 0x76, 0x2F, 0x6E, 0x75, 0x6C, 0x6C, 0x3B, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x65,
			0x78, 0x69, 0x74, 0x3B, 0x0D, 0x0A, 0x23, 0x26, 0x63, 0x6C, 0x73, 0x26, 0x73, 0x65, 0x74, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x45, 0x6E, 0x61, 0x62, 0x6C,
			0x65, 0x44, 0x65, 0x6C, 0x61, 0x79, 0x65, 0x64, 0x45, 0x78, 0x70, 0x61, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x26, 0x73, 0x65, 0x74, 0x20, 0x44, 0x49, 0x52, 0x3D,
			0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x65, 0x64, 0x26, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2E, 0x5C, 0x21,
			0x44, 0x49, 0x52, 0x21, 0x26, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x22, 0x25, 0x7E, 0x64, 0x70, 0x6E, 0x78, 0x30, 0x22, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52,
			0x21, 0x26, 0x63, 0x64, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x63, 0x6C, 0x73, 0x26, 0x74, 0x61, 0x72, 0x20, 0x2D, 0x78, 0x66, 0x20, 0x22,
			0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x26, 0x72, 0x65, 0x6E, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x20, 0x2A,
			0x2E, 0x70, 0x6E, 0x67, 0x26, 0x70, 0x6F, 0x77, 0x65, 0x72, 0x73, 0x68, 0x65, 0x6C, 0x6C, 0x20, 0x22, 0x49, 0x49, 0x20, 0x27, 0x27, 0x22, 0x26, 0x63, 0x6C,
			0x73, 0x26, 0x65, 0x78, 0x69, 0x74 },

		// Script Vector 7 for running a Linux executable file.
		{	0x49, 0x54, 0x45, 0x4D, 0x3D, 0x22, 0x22, 0x3B, 0x44, 0x49, 0x52, 0x3D, 0x22, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63,
			0x74, 0x65, 0x64, 0x22, 0x3B, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2D, 0x70, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22,
			0x3B, 0x6D, 0x76, 0x20, 0x22, 0x24, 0x30, 0x22, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x63, 0x64, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B,
			0x75, 0x6E, 0x7A, 0x69, 0x70, 0x20, 0x2D, 0x71, 0x6F, 0x20, 0x22, 0x24, 0x30, 0x22, 0x3B, 0x63, 0x68, 0x6D, 0x6F, 0x64, 0x20, 0x2B, 0x78, 0x20, 0x22, 0x24,
			0x49, 0x54, 0x45, 0x4D, 0x22, 0x3B, 0x2E, 0x2F, 0x22, 0x24, 0x49, 0x54, 0x45, 0x4D, 0x22, 0x20, 0x3B, 0x65, 0x78, 0x69, 0x74, 0x3B, 0x0D, 0x0A, 0x23, 0x26,
			0x63, 0x6C, 0x73, 0x26, 0x73, 0x65, 0x74, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x45, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x44, 0x65, 0x6C, 0x61, 0x79, 0x65, 0x64,
			0x45, 0x78, 0x70, 0x61, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x26, 0x73, 0x65, 0x74, 0x20, 0x44, 0x49, 0x52, 0x3D, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65,
			0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x65, 0x64, 0x26, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x6D, 0x6F, 0x76,
			0x65, 0x20, 0x22, 0x25, 0x7E, 0x64, 0x70, 0x6E, 0x78, 0x30, 0x22, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x63, 0x64, 0x20, 0x2E, 0x5C, 0x21,
			0x44, 0x49, 0x52, 0x21, 0x26, 0x63, 0x6C, 0x73, 0x26, 0x74, 0x61, 0x72, 0x20, 0x2D, 0x78, 0x66, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30,
			0x22, 0x26, 0x72, 0x65, 0x6E, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x20, 0x2A, 0x2E, 0x70, 0x6E, 0x67, 0x26, 0x63, 0x6C, 0x73,
			0x26, 0x65, 0x78, 0x69, 0x74 },

		// Script Vector 8 for running JAR (Java executable) files. 
		{	0x44, 0x49, 0x52, 0x3D, 0x22, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x65, 0x64, 0x22, 0x3B, 0x63, 0x6C, 0x65, 
			0x61, 0x72, 0x3B, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2D, 0x70, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x6D, 0x76, 0x20, 0x22, 0x24, 0x30, 0x22, 
			0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x63, 0x64, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x68, 0x61, 0x73, 0x68, 0x20, 0x2D, 0x72, 0x3B,
			0x69, 0x66, 0x20, 0x63, 0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x20, 0x2D, 0x76, 0x20, 0x6A, 0x61, 0x76, 0x61, 0x20, 0x3E, 0x2F, 0x64, 0x65, 0x76, 0x2F, 0x6E, 
			0x75, 0x6C, 0x6C, 0x20, 0x32, 0x3E, 0x26, 0x31, 0x3B, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x6A, 0x61, 0x76, 0x61, 0x20, 0x2D,
			0x6A, 0x61, 0x72, 0x20, 0x22, 0x24, 0x30, 0x22, 0x3B, 0x65, 0x6C, 0x73, 0x65, 0x20, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x66, 0x69, 0x3B, 0x65, 0x78, 0x69,
			0x74, 0x3B, 0x0D, 0x0A, 0x23, 0x26, 0x63, 0x6C, 0x73, 0x26, 0x73, 0x65, 0x74, 0x6C, 0x6F, 0x63, 0x61, 0x6C, 0x20, 0x45, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x44,
			0x65, 0x6C, 0x61, 0x79, 0x65, 0x64, 0x45, 0x78, 0x70, 0x61, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x26, 0x73, 0x65, 0x74, 0x20, 0x44, 0x49, 0x52, 0x3D, 0x70, 0x64,
			0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x65, 0x64, 0x26, 0x73, 0x65, 0x74, 0x20, 0x41, 0x50, 0x50, 0x3D, 0x6A, 0x61, 0x76,
			0x61, 0x26, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x22, 0x25, 0x7E, 0x64, 0x70,
			0x6E, 0x78, 0x30, 0x22, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x63, 0x64, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x63, 0x6C,
			0x73, 0x26, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x21, 0x41, 0x50, 0x50, 0x21, 0x20, 0x3E, 0x6E, 0x75, 0x6C, 0x20, 0x32, 0x3E, 0x26, 0x31, 0x20, 0x26, 0x26,
			0x20, 0x28, 0x21, 0x41, 0x50, 0x50, 0x21, 0x20, 0x2D, 0x6A, 0x61, 0x72, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x29, 0x20, 0x7C,
			0x7C, 0x20, 0x28, 0x63, 0x6C, 0x73, 0x29, 0x26, 0x72, 0x65, 0x6E, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x20, 0x2A, 0x2E, 0x70,
			0x6E, 0x67, 0x26, 0x65, 0x63, 0x68, 0x6F, 0x2E, 0x26, 0x65, 0x78, 0x69, 0x74 },

		// Script Vector 9 Default. For unmatched file extensions. Rely on Linux/Windows default application to deal with these files, if possible.
		{	0x49, 0x54, 0x45, 0x4D, 0x3D, 0x22, 0x22, 0x3B, 0x44, 0x49, 0x52, 0x3D, 0x22, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63,
			0x74, 0x65, 0x64, 0x22, 0x3B, 0x63, 0x6C, 0x65, 0x61, 0x72, 0x3B, 0x6D, 0x6B, 0x64, 0x69, 0x72, 0x20, 0x2D, 0x70, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22,
			0x3B, 0x6D, 0x76, 0x20, 0x22, 0x24, 0x30, 0x22, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B, 0x63, 0x64, 0x20, 0x22, 0x24, 0x44, 0x49, 0x52, 0x22, 0x3B,
			0x75, 0x6E, 0x7A, 0x69, 0x70, 0x20, 0x2D, 0x71, 0x6F, 0x20, 0x22, 0x24, 0x30, 0x22, 0x3B, 0x78, 0x64, 0x67, 0x2D, 0x6F, 0x70, 0x65, 0x6E, 0x20, 0x22, 0x24,
			0x49, 0x54, 0x45, 0x4D, 0x22, 0x3B, 0x65, 0x78, 0x69, 0x74, 0x3B, 0x0D, 0x0A, 0x23, 0x26, 0x63, 0x6C, 0x73, 0x26, 0x73, 0x65, 0x74, 0x6C, 0x6F, 0x63, 0x61,
			0x6C, 0x20, 0x45, 0x6E, 0x61, 0x62, 0x6C, 0x65, 0x44, 0x65, 0x6C, 0x61, 0x79, 0x65, 0x64, 0x45, 0x78, 0x70, 0x61, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x26, 0x73,
			0x65, 0x74, 0x20, 0x44, 0x49, 0x52, 0x3D, 0x70, 0x64, 0x76, 0x7A, 0x69, 0x70, 0x5F, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x65, 0x64, 0x26, 0x6D, 0x6B,
			0x64, 0x69, 0x72, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x6D, 0x6F, 0x76, 0x65, 0x20, 0x22, 0x25, 0x7E, 0x64, 0x70, 0x6E, 0x78, 0x30, 0x22,
			0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x63, 0x64, 0x20, 0x2E, 0x5C, 0x21, 0x44, 0x49, 0x52, 0x21, 0x26, 0x63, 0x6C, 0x73, 0x26, 0x74, 0x61,
			0x72, 0x20, 0x2D, 0x78, 0x66, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30, 0x25, 0x7E, 0x78, 0x30, 0x22, 0x26, 0x72, 0x65, 0x6E, 0x20, 0x22, 0x25, 0x7E, 0x6E, 0x30,
			0x25, 0x7E, 0x78, 0x30, 0x22, 0x20, 0x2A, 0x2E, 0x70, 0x6E, 0x67, 0x26, 0x22, 0x22, 0x26, 0x65, 0x63, 0x68, 0x6F, 0x2E, 0x26, 0x65, 0x78, 0x69, 0x74 }
	};

	// Vector "Case_Values_Vec", will contain between 1 and 5 values depending on the matched file extension.
	// The first value in the vector is always one of the Script Vectors within the vector array "Extraction_Scripts_Array_Vec".
	// The remaining values are insert index locations within the Script Vector for elements to be inserted, such as filenames & command arguments, which completes the extraction script.
	std::vector<int> Case_Values_Vec;

	switch (extension_index) {
		case VIDEO_AUDIO: {
			Case_Values_Vec = { 0, 484, 28 };
			break;
		}
		case PDF: {
			Case_Values_Vec = { 1, 406, 28 };
			break;
		}
		case PYTHON: {
			Case_Values_Vec = { 2, 267, 257, 188, 28 };
			break;
		}
		case POWERSHELL: {
			Case_Values_Vec = { 3, 261, 251, 182, 51 };
			break;
		}
		case WINDOWS_EXECUTABLE: {
			Case_Values_Vec = { 4, 278, 276 };
			break;
		}
		case BASH_SHELL: {
			Case_Values_Vec = { 5, 308, 306, 142, 28 };
			break;
		}
		case FOLDER: {
			Case_Values_Vec = { 6, 329, 28 };
			break;
		}
		case LINUX_EXECUTABLE: {
			Case_Values_Vec = { 7, 142, 28 };
			break;
		}
		case JAR: {
			Case_Values_Vec = { 8 };
			break;
		}
		default: {
			Case_Values_Vec = { 9, 295, 28 };
		}
	}

	const int
		SCRIPT_VECTOR = Case_Values_Vec[0],
		SCRIPT_VECTOR_INSERT_INDEX = 22;

	// Insert the selected "Script Vector" extraction script into the vector "Iccp_Script_Vec".
	Iccp_Script_Vec.insert(Iccp_Script_Vec.begin() + SCRIPT_VECTOR_INSERT_INDEX, Extraction_Scripts_Array_Vec[SCRIPT_VECTOR].begin(), Extraction_Scripts_Array_Vec[SCRIPT_VECTOR].end());

	if (pdv.isZipFile) { // We don't need to add anything to the script if we have a JAR file. Skip this section.

		// Update the selected script, that's now in vector "Iccp_Script_Vec", with the required filenames and command arguments.
		if (extension_index == WINDOWS_EXECUTABLE) {
			Iccp_Script_Vec.insert(Iccp_Script_Vec.begin() + Case_Values_Vec[1], args_windows.begin(), args_windows.end());
			Iccp_Script_Vec.insert(Iccp_Script_Vec.begin() + Case_Values_Vec[2], first_zip_name.begin(), first_zip_name.end());
		}
		else if (extension_index == LINUX_EXECUTABLE) {
			Iccp_Script_Vec.insert(Iccp_Script_Vec.begin() + Case_Values_Vec[1], args_linux.begin(), args_linux.end());
			Iccp_Script_Vec.insert(Iccp_Script_Vec.begin() + Case_Values_Vec[2], first_zip_name.begin(), first_zip_name.end());
		}
		else if (extension_index == PYTHON || extension_index == POWERSHELL || extension_index == BASH_SHELL) {
			Iccp_Script_Vec.insert(Iccp_Script_Vec.begin() + Case_Values_Vec[1], args_windows.begin(), args_windows.end());
			Iccp_Script_Vec.insert(Iccp_Script_Vec.begin() + Case_Values_Vec[2], first_zip_name.begin(), first_zip_name.end());
			Iccp_Script_Vec.insert(Iccp_Script_Vec.begin() + Case_Values_Vec[3], args_linux.begin(), args_linux.end());
			Iccp_Script_Vec.insert(Iccp_Script_Vec.begin() + Case_Values_Vec[4], first_zip_name.begin(), first_zip_name.end());
		}
		else {
			Iccp_Script_Vec.insert(Iccp_Script_Vec.begin() + Case_Values_Vec[1], first_zip_name.begin(), first_zip_name.end());
			Iccp_Script_Vec.insert(Iccp_Script_Vec.begin() + Case_Values_Vec[2], first_zip_name.begin(), first_zip_name.end());
		}
	}
		
	size_t 
		iccp_chunk_script_size = Iccp_Script_Vec.size() - 12,
		iccp_chunk_length_index = 2;

	pdv.value_length_bits = 16;

	// Write updated chunk length value for the "iCCP" chunk into its length field. 
	// Due to its small size, the "iCCP" chunk will only use 2 bytes maximum (bits=16) of the 4 byte length field.

	Value_Updater(pdv, Iccp_Script_Vec, iccp_chunk_length_index, iccp_chunk_script_size);

	// Check the first byte (low-order byte) of the "iCCP" chunk length field to make sure the updated chunk length does not match 
	// any of the problem characters that will break the Linux extraction script.

	for (int i = 0; i < 7; i++) {
		if (Iccp_Script_Vec[3] == pdv.LINUX_PROBLEM_CHARACTERS[i]) {

			// Problem character found. Insert a 10 bytes string at the end of "Iccp_Script_Vec", just before crc field, to increase the chunk length. Update chunk length field. 
			// This should now skip over any problem characters, regardless of the new chunk size.

			const std::string INCREASE_LENGTH_STRING = "..........";

			Iccp_Script_Vec.insert(Iccp_Script_Vec.begin() + iccp_chunk_script_size + 8, INCREASE_LENGTH_STRING.begin(), INCREASE_LENGTH_STRING.end());
			iccp_chunk_script_size = Iccp_Script_Vec.size() - 12;

			pdv.value_length_bits = 16;
			iccp_chunk_length_index = 2;
			
			Value_Updater(pdv, Iccp_Script_Vec, iccp_chunk_length_index, iccp_chunk_script_size); // Update size again.

			break;
		}
	}

	pdv.combined_file_size = Iccp_Script_Vec.size() + pdv.Image_Vec.size() + pdv.Idat_Zip_Vec.size();

	constexpr int
		MAX_SCRIPT_SIZE = 1500,
		ICCP_CHUNK_NAME_INDEX = 4;  // When calculating the CRC value for a PNG chunk, we always begin at and include the chunk name field.

	if (iccp_chunk_script_size > MAX_SCRIPT_SIZE || pdv.combined_file_size > pdv.MAX_FILE_SIZE) {
		std::cerr << "\nFile Size Error: " << (iccp_chunk_script_size > MAX_SCRIPT_SIZE ? "Extraction script exceeds size limit"
			: "The combined file size of your PNG image, ZIP file and Extraction Script, exceeds file size limit") << ".\n\n";
		std::exit(EXIT_FAILURE);
	}

	// Now the "iCCP" chunk is complete with the extraction script, we need to update the chunk's CRC value.
	// Pass these two values (ICCP_CHUNK_NAME_INDEX & ICCP_CHUNK_LENGTH to the CRC function to get correct "iCCP" chunk CRC value.

	const size_t
		ICCP_CHUNK_LENGTH = iccp_chunk_script_size + 4,
		ICCP_CHUNK_CRC = Crc(&Iccp_Script_Vec[ICCP_CHUNK_NAME_INDEX], ICCP_CHUNK_LENGTH);

	// Get vector index location for the "iCCP" chunk's 4 byte CRC value field.
	size_t iccp_chunk_crc_index = iccp_chunk_script_size + 8;

	pdv.value_length_bits = 32;

	// Write the updated CRC value into the vector "Iccp_Script_Vec" chunk's CRC field (4 bytes).
	Value_Updater(pdv, Iccp_Script_Vec, iccp_chunk_crc_index, ICCP_CHUNK_CRC);

	// Insert contents of vectors "Iccp_Script_Vec", containing iCCP chunk with the completed extraction script and "Idat_Zip_Vec", containing IDAT chunk with the ZIP file, into vector "Image_Vec" (User's PNG cover image).

	// This value will be used as the insert location within vector "Image_Vec" for contents of "Iccp_Script_Vec". 
	constexpr int ICCP_CHUNK_INSERT_INDEX = 33;

	// The "Iccp_Script_Vec" inserted contents will appear just after the "IHDR" chunk as the "iCCP" chunk, within vector "Image_Vec".
	pdv.Image_Vec.insert((pdv.Image_Vec.begin() + ICCP_CHUNK_INSERT_INDEX), Iccp_Script_Vec.begin(), Iccp_Script_Vec.end());
		
	// Insert contents of vector "Idat_Zip_Vec" ("IDAT" chunk with ZIP file) into vector "Image_Vec".
	// This now becomes the last "IDAT" chunk of the PNG image within vector "Image_Vec".
	pdv.Image_Vec.insert((pdv.Image_Vec.end() - 12), pdv.Idat_Zip_Vec.begin(), pdv.Idat_Zip_Vec.end());

	// We have finished with these vectors. 
	Iccp_Script_Vec.clear();  pdv.Idat_Zip_Vec.clear();
	Iccp_Script_Vec.shrink_to_fit();  pdv.Idat_Zip_Vec.shrink_to_fit();

	const size_t LAST_IDAT_CHUNK_NAME_INDEX = pdv.image_size + iccp_chunk_script_size + 4;  // Set the index position to the start of the last "IDAT" chunk name field.

	// Before updating the last "IDAT" chunk's CRC value, adjust ZIP file offsets within this chunk, to their new locations, so that the ZIP file continues to be valid & extractable.
	Fix_Zip_Offset(pdv, LAST_IDAT_CHUNK_NAME_INDEX);

	const size_t LAST_IDAT_CHUNK_CRC = Crc(&pdv.Image_Vec[LAST_IDAT_CHUNK_NAME_INDEX], pdv.zip_size - 8); // We don't include the length or CRC fields (-8 bytes).

	pdv.image_size = pdv.Image_Vec.size();

	size_t last_idat_chunk_crc_index = pdv.image_size - 16;

	pdv.isBigEndian = true;
	pdv.value_length_bits = 32;

	Value_Updater(pdv, pdv.Image_Vec, last_idat_chunk_crc_index, LAST_IDAT_CHUNK_CRC);

	Write_Polyglot_File(pdv);
}

void Fix_Zip_Offset(PDV_STRUCT& pdv, const size_t& LAST_IDAT_CHUNK_NAME_INDEX) {

	const std::string
		START_CENTRAL_DIR_SIG = "PK\x01\x02",
		END_CENTRAL_DIR_SIG = "PK\x05\x06",
		ZIP_SIG = "PK\x03\x04";

	const size_t
		START_CENTRAL_DIR_INDEX = std::search(pdv.Image_Vec.begin() + LAST_IDAT_CHUNK_NAME_INDEX, pdv.Image_Vec.end(), START_CENTRAL_DIR_SIG.begin(), START_CENTRAL_DIR_SIG.end()) - pdv.Image_Vec.begin(),
		END_CENTRAL_DIR_INDEX = std::search(pdv.Image_Vec.begin() + START_CENTRAL_DIR_INDEX, pdv.Image_Vec.end(), END_CENTRAL_DIR_SIG.begin(), END_CENTRAL_DIR_SIG.end()) - pdv.Image_Vec.begin();

	size_t
		zip_records_index = END_CENTRAL_DIR_INDEX + 11,
		zip_comment_length_index = END_CENTRAL_DIR_INDEX + 21,
		end_central_start_index = END_CENTRAL_DIR_INDEX + 19,
		central_local_index = START_CENTRAL_DIR_INDEX - 1,
		new_offset = LAST_IDAT_CHUNK_NAME_INDEX;

	int zip_records = (pdv.Image_Vec[zip_records_index] << 8) | pdv.Image_Vec[zip_records_index - 1];	// Get ZIP file records value from index location of vector "Image_Vec".
	
	pdv.value_length_bits = 32;
	pdv.isBigEndian = false;

	// Starting from the last "IDAT" chunk, search for ZIP file record offsets and update them to their new offset location.
	while (zip_records--) {
		new_offset = std::search(pdv.Image_Vec.begin() + new_offset + 1, pdv.Image_Vec.end(), ZIP_SIG.begin(), ZIP_SIG.end()) - pdv.Image_Vec.begin(),
		central_local_index = 45 + std::search(pdv.Image_Vec.begin() + central_local_index, pdv.Image_Vec.end(), START_CENTRAL_DIR_SIG.begin(), START_CENTRAL_DIR_SIG.end()) - pdv.Image_Vec.begin();
		Value_Updater(pdv, pdv.Image_Vec, central_local_index, new_offset);
	}

	Value_Updater(pdv, pdv.Image_Vec, end_central_start_index, START_CENTRAL_DIR_INDEX);

	// JAR file support. Get archive comment length value from ZIP file within vector "Image_Vec" and increase it by 16 bytes to cover end of PNG file.

	int zip_comment_length = 16 + (static_cast<size_t>(pdv.Image_Vec[zip_comment_length_index] << 8) | (static_cast<size_t>(pdv.Image_Vec[zip_comment_length_index - 1])));

	pdv.value_length_bits = 16;

	Value_Updater(pdv, pdv.Image_Vec, zip_comment_length_index, zip_comment_length);
}

void Write_Polyglot_File(PDV_STRUCT& pdv) {

	srand((unsigned)time(NULL));  // For output filename.

	const std::string
		NAME_VALUE = std::to_string(rand()),
		PDV_FILENAME = "pzip_" + NAME_VALUE.substr(0, 5) + ".png"; // Unique filename for the complete polyglot image.

	std::ofstream file_ofs(PDV_FILENAME, std::ios::binary);

	if (!file_ofs) {
		std::cerr << "\nWrite File Error: Unable to write to file.\n\n";
		std::exit(EXIT_FAILURE);
	}

	file_ofs.write((char*)&pdv.Image_Vec[0], pdv.image_size);

	std::cout << "\nCreated " << (pdv.isZipFile ? "PNG-ZIP" : "PNG-JAR") << " polyglot image file: " + PDV_FILENAME + '\x20' + std::to_string(pdv.image_size) + " Bytes.\n\nComplete!\n\nYou can now post your image on the relevant supported platforms.\n\n";
}

// The following code (slightly modified) to compute CRC32 for PNG chunks, was taken from: https://www.w3.org/TR/2003/REC-PNG-20031110/#D-CRCAppendix 
size_t Crc_Update(const size_t& Crc, Byte* buf, const size_t& len) {
	// Table of CRCs of all 8-bit messages.
	constexpr size_t Crc_Table[256]{
		0x00, 	    0x77073096, 0xEE0E612C, 0x990951BA, 0x76DC419,  0x706AF48F, 0xE963A535, 0x9E6495A3, 0xEDB8832,  0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x9B64C2B,  0x7EB17CBD,
		0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
		0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
		0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
		0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x1DB7106,  0x98D220BC, 0xEFD5102A, 0x71B18589, 0x6B6B51F,
		0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0xF00F934,  0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x86D3D2D,  0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
		0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE,
		0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
		0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
		0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x3B6E20C,  0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x4DB2615,  0x73DC1683, 0xE3630B12, 0x94643B84, 0xD6D6A3E,  0x7A6A5AA8,
		0xE40ECF0B, 0x9309FF9D, 0xA00AE27,  0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0,
		0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
		0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703,
		0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x26D930A,
		0x9C0906A9, 0xEB0E363F, 0x72076785, 0x5005713,  0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0xCB61B38,  0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0xBDBDF21,  0x86D3D2D4, 0xF1D4E242,
		0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
		0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5,
		0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
		0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D };

	// Update a running CRC with the bytes buf[0..len - 1] the CRC should be initialized to all 1's, 
	// and the transmitted value is the 1's complement of the final running CRC (see the crc() routine below).
	size_t c = Crc;

	for (int n = 0; n < len; n++) {
		c = Crc_Table[(c ^ buf[n]) & 0xff] ^ (c >> 8);
	}
	return c;
}

// Return the CRC of the bytes buf[0..len-1].
size_t Crc(Byte* buf, const size_t& len)
{
	return Crc_Update(0xffffffffL, buf, len) ^ 0xffffffffL;
}

void Value_Updater(PDV_STRUCT& pdv, std::vector<Byte>& vec, size_t& value_insert_index, const size_t& NEW_VALUE) {
	 
	if (pdv.isBigEndian) {
		while (pdv.value_length_bits) {
			static_cast<size_t>(vec[value_insert_index++] = (NEW_VALUE >> (pdv.value_length_bits -= 8)) & 0xff);
		}
	}
	else {
		while (pdv.value_length_bits) {
			static_cast<size_t>(vec[value_insert_index--] = (NEW_VALUE >> (pdv.value_length_bits -= 8)) & 0xff);
		}
	}
	pdv.value_length_bits = 32;
}

void Display_Info() {

	std::cout << R"(
PNG Data Vehicle ZIP Edition (PDVZIP v2.2). Created by Nicholas Cleasby (@CleasbyCode) 6/08/2022.
		
PDVZIP enables you to embed a ZIP file within a *tweetable and "executable" PNG image.  		
		
The hosting sites will retain the embedded arbitrary data within the PNG image.  
		
PNG image size limits are platform dependant:  

X/Twitter (5MB), Flickr (200MB), Imgbb (32MB), PostImage (24MB), ImgPile (8MB).

Once the ZIP file has been embedded within a PNG image, it can be shared on your chosen
hosting site or 'executed' whenever you want to access the embedded file(s).

From a Linux terminal: ./pzip_image.png (Image file requires executable permissions / chmod +x pzip_image.png).
From a Windows terminal: First, rename the '.png' file extension to '.cmd', then .\pzip_image.cmd 

For common video/audio files, Linux uses the media player vlc or mpv. Windows uses the set default media player.
PDF, Linux uses either evince or firefox. Windows uses the set default PDF viewer.
Python, Linux & Windows use python3 to run these programs.
PowerShell, Linux uses pwsh command (if PowerShell installed). 
Depending on the installed version of PowerShell, Windows uses either pwsh.exe or powershell.exe, to run these scripts.
Folder, Linux uses xdg-open, Windows uses powershell.exe with II (Invoke-Item) command, to open zipped folders.

For any other media type/file extension, Linux & Windows will rely on the operating system's method or set default application for those files.

PNG Image Requirements for Arbitrary Data Preservation

PNG file size (image + embedded content) must not exceed the hosting site's size limits.
The site will either refuse to upload your image or it will convert your image to jpg, such as X/Twitter.

Dimensions:

The following dimension size limits are specific to pdvzip and not necessarily the extact hosting site's size limits.

PNG-32/24 (Truecolor)

Image dimensions can be set between a minimum of 68 x 68 and a maximum of 899 x 899.
These dimension size limits are for compatibility reasons, allowing it to work with all the above listed platforms.

Note: Images that are created & saved within your image editor as PNG-32/24 that are either 
black & white/grayscale, images with 256 colours or less, will be converted by X/Twitter to 
PNG-8 and you will lose the embedded content. If you want to use a simple "single" colour PNG-32/24 image,
then fill an area with a gradient colour instead of a single solid colour.
X/Twitter should then keep the image as PNG-32/24.

PNG-8 (Indexed-colour [3])

Image dimensions can be set between a minimum of 68 x 68 and a maximum of 4096 x 4096.

PNG Chunks:

For example, with X/Twitter, you can overfill the following PNG chunks with arbitrary data, 
in which the platform will preserve as long as you keep within the image dimension & file size limits.  

Other platforms may differ in what chunks they preserve and which you can overfill.

bKGD, cHRM, gAMA, hIST,
iCCP, (Only 10KB max. with X/Twitter).
IDAT, (Use as last IDAT chunk, after the final image IDAT chunk).
PLTE, (Use only with PNG-32 & PNG-24 for arbitrary data).
pHYs, sBIT, sPLT, sRGB,
tRNS. (Not recommended, may distort image).

This program uses the iCCP (extraction script) and IDAT (zip file) chunk names for storing arbitrary data.

ZIP File Size & Other Information

To work out the maximum ZIP file size, start with the hosting site's size limit,  
minus your PNG image size, minus 1500 bytes (extraction script size).   

X/Twitter example: (5MB Image Limit) 5,242,880 - (image size 307,200 + extraction script size 1500) = 4,934,180 bytes available for your ZIP file.

Make sure ZIP file is a standard ZIP archive, compatible with Linux unzip & Windows Explorer.
Do not include other .zip files within the main ZIP archive. (.rar files are ok).
Do not include other pdvzip created PNG image files within the main ZIP archive, as they are essentially .zip files.
Use file extensions for your media file within the ZIP archive: my_doc.pdf, my_video.mp4, my_program.py, etc.
A file without an extension will be treated as a Linux executable.
Paint.net application is recommended for easily creating compatible PNG image files.
 
)";
}
